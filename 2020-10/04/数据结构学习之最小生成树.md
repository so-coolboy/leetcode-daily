### 最小生成树 ###
把构造连通网的最小代价生成树称为最小生成树。

### Prim算法 ###
Prim算法流程：
1，从所有顶点中任选一个顶点x0，加入到已选顶点集合V1，然后遍历与它邻接的所有顶点，找到最小权重的顶点x1，将这条边加入到边的集合E1中。
2，将新找到的顶点x1加入到已选集合V2中，此时遍历x0，x1邻接的所有顶点，找到最小权值的边对应的顶点x2，把边加入到E2中。
3，重复以上过程，直到所有的顶点被遍历，此时生成的边集合中的权值就是最小生成树的权值。路径也可以由边集合得到。

注意：下面的算法中，需要仔细理解的是adjvex和lowcast两个数组。
先说lowcast，它的大小与顶点数目相同，每一个位置都代表了对应顶点位置的权值，注意，这个顶点，是已经便利的顶点集合相对于没有便利的顶点集合的权值，所以他是一直变化的，比如
如果只有v0被遍历了，那么这个数组中的元素就是v0到其他顶点的权值，但是如果是v0，v1被遍历了，那么数组中的元素就是v0，v1到其他顶点的权值中，而且取得是极小值，比如v0，v1都和
v2有连接，那么v2对应权值是这两个的极小值。

adjvex数组记录的则是当根据此时的最小权值选取了顶点后，比如为k，那么在已选取集合中，与它构成最小权值边的另一个点是adjvex[k].也就是说，数组的值与下标构成了对应的最小权值边
的两个顶点。

//邻接矩阵的Prim算法
```
void MiniSpanTree_Prim(MGraph G)
{
    int min, i,j,k;
    int adjvex[MAXVEX];    //
    int lowcost[MAXVEX];   //随着顶点的增加，这个记录权值的数组一直在变化，每次都从这里面找到当时对应的最小权值。
    lowcost[0] = 0;    //初始化第一个权值是0，也就是把第一个点x0加入进去。  也就是说，为了标记这个点已经加入到已选顶点集合中，就把它的权值置为0.
    adjvex[0] = 0;   //选择第一个顶点，因此标记数组对应位置为0
    for(i=1; i<G.numVertexes; i++)
    {
        lowcost[i] = G.arc[0][i];   //把v0顶点有关的边的权值存进去
        adjvex[i] = 0;     //初始化都是v0的下标
    }
    for(i=1; i<G.numVertexes; i++)
    {
        min = INFINYTY;   //初始化最小权值为无穷
        j=1;
        k=0;
        while(j<G.numVertexes)     //这个循环的目的就是选取lowcast中当前最小的权值边
        {
            if(lowcast[j]!=0 && lowcast[j] < min)     //不为0是为了不重复选取已经在已选取集合中的元素
            {
                min = lowcast[j];   //让当前权重成为最小值
                k = j;    //记录当前位置
            }
            j++；
         }
         
         printf("(%d, %d)", adjvex[k], k);   //打印当前顶点边中权值最小边
         lowcast[k] = 0;   //将当前顶点的权值设置为0， 表示此顶点已经完成任务
         for(j=1; j<G.numVertexes; j++)     //因为已选集合加入了新的元素，因此每个点的权值也要更新了
         {
            if(lowcast[j]!=0 && G.arc[k][j] < lowcast[j])    //只需要判断新加入节点的邻接权值与当前的lowcast中的权值比较就可以了。
            {
                lowcast[j] = G.arc[k][j];
                adjvex[j] = k;                                //记录是哪个点到当前点的权值在此位置最小。
             }
         }
     }
}
```
                
    
    
