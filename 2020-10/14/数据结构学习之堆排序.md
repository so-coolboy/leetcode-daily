### 堆定义 ###
堆是具有下列性质的完全二叉树，每个节点的值都大于等于它左右孩子节点的值，称为大顶堆；每个结点的值都小于等于它左右孩子结点的值，称为小顶堆。

### 堆排序算法 ###
堆排序的基本思想是将待排序的序列构成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点，将它移走（其实就是将它与堆数组的末尾元素置换，此时末尾元素就是最大值），
然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值，如此反复执行，就能得到一个有序序列。

### 代码 ###
关于算法的直观理解参照：https://www.cnblogs.com/chengxiao/p/6129630.html

//对顺序表进行堆排序的整体代码
```
void HeapSort(SqList *L)
{
    int i;
    for(i = L->length/2; i>=0; i--)   //构造大顶堆，从非叶子结点开始
    {
        HeapAdjust(L, i, L->length);
    }
    
    for(i=L->length; i>1; i--)
    {
        swap(L, 1, i);   //将堆顶记录和当前未经排序的子序列进行交换
        HeapAdjust(L, 1, i-1);   //将L-r[1..i-1]重新调整为大顶堆
    }
}
```

//堆调整函数
```
void HeapAdjust(SqList *L, int s, int m)
{
    int temp, j;
    temp = L->r[s];
    for(j=2*s; j<=m; j*=2)   //沿关键字较大的孩子节点向下筛选
    {
        if(j<m && L->r[j]<L->r[j+1])     //从左到右
            ++j;    //j为关键字中较大的记录的下标
        if(temp>-L->r[j])
            break;    
        L->r[s] = L->r[j];
        s = j;
    }
    L->r[s] = temp;    //插入
}
```
