### Set ###
关联容器包括set、map.
关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。
关联容器不支持顺序容器的位置相关的操作。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入
操作这些接受一个元素值和一个数量值得操作。
关联容器支持高效的关键字查找和访问。两个主要的关联容器(associative container)类型是map和set。map中的元素是一些关键字----值(key--value)对：
关键字起到索引的作用，值则表示与索引相关联的数据。set中每个元素只包含一个关键字：set支持高效的关键字查询操作----检查一个给定关键字是否在set中。

### 标准库提供set关联容器 ###
1，按关键字有序保存元素：set(关键字即值，即只保存关键字的容器)；multiset(关键字可重复出现的set)；  
2，无序集合：unordered_set(用哈希函数组织的set)；unordered_multiset(哈希组织的set，关键字可以重复出现)。  
set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的。

在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。set中元素的值不能直接被改变。set内部采用的是一种非常高效的平衡检索二叉树：红黑树，
也称为RB树(Red-Black Tree)。RB树的统计性能要好于一般平衡二叉树。

set具备的两个特点：
* set中的元素都是排序好的
* set中的元素都是唯一的，没有重复的

### Set常用函数 ###
* begin();            // 返回指向第一个元素的迭代器
* end();              // 返回指向最后一个元素的迭代器
* clear();            // 清除所有元素
* count();            // 返回某个值元素的个数
* empty();            // 如果集合为空，返回true
* equal_range();      //返回集合中与给定值相等的上下限的两个迭代器
* erase()–删除集合中的元素
* find()–返回一个指向被查找到元素的迭代器
* get_allocator()–返回集合的分配器
* insert()–在集合中插入元素
* lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器
* key_comp()–返回一个用于元素间值比较的函数
* max_size()–返回集合能容纳的元素的最大限值
* rbegin()–返回指向集合中最后一个元素的反向迭代器
* rend()–返回指向集合中第一个元素的反向迭代器
* size()–集合中元素的数目
* swap()–交换两个集合变量
* upper_bound()–返回大于某个值元素的迭代器
* value_comp()–返回一个用于比较元素间的值的函数

### 为何map和set的插入删除效率比用其他序列容器高？ ###
因为对于关联容器来说，不需要做内存拷贝和内存移动。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。
因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点也OK了。
这里的一切操作就是指针换来换去，和内存移动没有关系。

### 当数据元素增多时，set的插入和搜索速度变化如何？ ###
如果你知道log2的关系你应该就彻底了解这个答案。在set中查找是使用二分查找，也就是说，如果有16个元素，最多需要比较4次就能找到结果，
有32个元素，最多比较5次。那么有10000个呢？最多比较的次数为log10000，最多为14次，如果是20000个元素呢？最多不过15次。
